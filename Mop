<template>
  <div id="app" class="container-fluid">
    <div class="row">
      <div class="col-12">
        <div class="controls d-flex justify-content-end align-items-center">
          <button @click="saveChanges" class="btn btn-primary save-button">Save Changes</button>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-12">
        <div id="mynetwork"></div>
      </div>
    </div>

    <!-- Modal -->
    <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="exampleModalLabel">Node Label</h5>
            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <input type="text" class="form-control" v-model="modalLabel" @keypress.enter="saveLabel">
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary" @click="saveLabel">Save</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { Network } from "vis-network/standalone/umd/vis-network.min.js";

export default {
  data() {
    return {
      allNodes: [],
      allEdges: [],
      nodes: null,
      edges: null,
      network: null,
      modalLabel: "",
      currentNodeData: null,
    };
  },
  methods: {
    async loadTreeData() {
      try {
        const response = await fetch("/tree.json");
        if (!response.ok) {
          throw new Error("Network response was not ok " + response.statusText);
        }
        return await response.json();
      } catch (error) {
        console.error("Error loading tree data:", error);
      }
    },
    filterNodes(currentNodeId) {
      const newNodes = [];
      const newEdges = [];

      const currentNode = this.allNodes.find((node) => node.id === currentNodeId);
      newNodes.push(currentNode);

      const parentEdge = this.allEdges.find((edge) => edge.to === currentNodeId);
      if (parentEdge) {
        const parentNode = this.allNodes.find((node) => node.id === parentEdge.from);
        newNodes.push(parentNode);
        newEdges.push(parentEdge);
      }

      const childEdges = this.allEdges.filter((edge) => edge.from === currentNodeId);
      childEdges.forEach((edge) => {
        const childNode = this.allNodes.find((node) => node.id === edge.to);
        newNodes.push(childNode);
        newEdges.push(edge);
      });

      return { nodes: newNodes, edges: newEdges };
    },
    createNetwork(treeData) {
      this.allNodes = treeData.nodes;
      this.allEdges = treeData.edges;

      const rootNodeId = this.allNodes[0].id;
      const filteredData = this.filterNodes(rootNodeId);

      this.nodes = new vis.DataSet(filteredData.nodes);
      this.edges = new vis.DataSet(filteredData.edges);

      const container = document.getElementById("mynetwork");
      const data = { nodes: this.nodes, edges: this.edges };

      const options = {
        layout: {
          hierarchical: {
            direction: "LR",
            sortMethod: "directed",
          },
        },
        nodes: {
          shape: "box",
          fixed: true,
          font: { size: 12 },
          widthConstraint: { maximum: 100 },
        },
        edges: { smooth: true },
        interaction: {
          dragNodes: false,
          dragView: true,
          zoomView: true,
          selectable: true,
        },
        manipulation: {
          enabled: true,
          addNode: (data, callback) => {
            this.openModal("", callback);
          },
          editNode: (data, callback) => {
            this.openModal(data.label, callback);
          },
        },
      };

      this.network = new vis.Network(container, data, options);

      this.network.on("click", (params) => {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          const filteredData = this.filterNodes(nodeId);
          this.nodes.clear();
          this.edges.clear();
          this.nodes.add(filteredData.nodes);
          this.edges.add(filteredData.edges);
        }
      });

      this.network.on("stabilized", () => {
        this.network.fit();
      });
    },
    async saveChanges() {
      const updatedNodes = this.nodes.get();
      const updatedEdges = this.edges.get();
      const updatedData = {
        nodes: updatedNodes,
        edges: updatedEdges,
      };

      try {
        const response = await fetch("/save", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updatedData),
        });
        if (response.ok) {
          alert("Changes saved successfully!");
        } else {
          alert("Failed to save changes.");
        }
      } catch (error) {
        console.error("Error:", error);
      }
    },
    openModal(label, callback) {
      this.modalLabel = label;
      $("#myModal").modal("show");
      this.currentNodeData = callback;
    },
    saveLabel() {
      const newNodeLabel = this.modalLabel.trim();
      if (newNodeLabel && this.currentNodeData) {
        this.currentNodeData({ label: newNodeLabel });
        $("#myModal").modal("hide");
      } else {
        alert("Please enter a valid label.");
      }
    },
  },
  async mounted() {
    const treeData = await this.loadTreeData();
    this.createNetwork(treeData);
  },
};
</script>

<style scoped>
#mynetwork {
  border: 1px solid lightgray;
  height: 500px;
}

.save-button {
  margin-left: 10px;
}
</style>
